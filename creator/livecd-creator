#!/usr/bin/python -tt
#
# livecd-creator : Creates Live CD based for Fedora.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

import getopt
import os
import os.path
import sys
import tempfile
import time
import traceback
import subprocess
import shutil
import yum
import pykickstart.parser
import pykickstart.version

class InstallationError(Exception):
    def __init__(self, msg):
        Exception.__init__(self, msg)

class BindChrootMount:
    """Represents a bind mount of a directory into a chroot."""
    def __init__(self, src, chroot, dest = None):
        self.src = src
        self.root = chroot
        if dest:
            self.dest = dest
        else:
            self.dest = src

        self.mounted = False

    def mount(self):
        if not self.mounted:
            if not os.path.exists("%s/%s" %(self.root, self.dest)):
                os.makedirs("%s/%s" %(self.root, self.dest))
            rc = subprocess.call(["/bin/mount", "--bind", self.src,
                                  "%s/%s" %(self.root, self.dest)])
            if rc == 0:
                self.mounted = True
        return self.mounted

    def umount(self):
        if self.mounted:
            rc = subprocess.call(["/bin/umount",
                                  "%s/%s" %(self.root, self.dest)])
            self.mounted = False
        

class LoopbackMount:
    def __init__(self, lofile, mountdir, fstype = None):
        self.lofile = lofile
        self.mountdir = mountdir
        self.fstype = fstype

        self.mounted = False
        self.losetup = False
        self.loopdev = None

    def cleanup(self, rmdir = True):
        self.umount()
        self.lounsetup()
        if rmdir:
            try:
                os.rmdir(self.mountdir)
            except OSError, e:
                pass

    def umount(self):
        if self.mounted:
            rc = subprocess.call(["/bin/umount", self.mountdir])
            self.mounted = False

    def lounsetup(self):
        if self.losetup and self.loopdev:
            rc = subprocess.call(["/sbin/losetup", "-d", self.loopdev])
            self.losetup = False
            self.loopdev = None

    def setup(self):
        if not os.path.exists(self.mountdir):
            os.makedirs(self.mountdir)
        if self.loopsetup():
            if self.mount():
                return True
        return False

    def loopsetup(self):
        if self.losetup:
            return self.losetup
        rc = subprocess.call(["/sbin/losetup", "-f", self.lofile])
        if rc != 0:
            return self.losetup

        # succeeded; figure out which loopdevice we're using
        buf = subprocess.Popen(["/sbin/losetup", "-a"],
                               stdout=subprocess.PIPE).communicate()[0]
        for line in buf.split("\n"):
            # loopdev: fdinfo (filename)
            fields = line.split()
            if len(fields) != 3:
                continue
            if fields[2] == "(%s)" %(self.lofile,):
                self.loopdev = fields[0][:-1]
                break

        if self.loopdev:
            self.losetup = True
        return self.losetup

    def mount(self):
        if self.mounted or not self.loopdev:
            return self.mounted
        args = [ "/bin/mount", self.loopdev, self.mountdir ]
        if self.fstype:
            args.extend(["-t", self.fstype])
        rc = subprocess.call(args)
        if rc == 0:
            self.mounted = True
        return self.mounted

class SparseExt3LoopbackMount(LoopbackMount):
    def __init__(self, lofile, mountdir, size, fslabel = None):
        LoopbackMount.__init__(self, lofile, mountdir, fstype = "ext3")
        self.size = size
        self.fslabel = fslabel
        if not self.fslabel:
            self.fslabel = "livecd-" + time.strftime("%Y%m%d-%H%M")

    def _createSparseFile(self):
        dir = os.path.dirname(self.lofile)
        if not dir:
            os.makedirs(dir)

        # create the sparse file
        fd = os.open(self.lofile, os.O_WRONLY | os.O_CREAT)
        off = long(self.size * 1024L * 1024L)
        os.lseek(fd, off, 0)
        os.write(fd, '\x00')
        os.close(fd)

    def _formatFilesystem(self):
        rc = subprocess.call(["/sbin/mkfs.ext3", "-F", "-L", self.fslabel,
                              "-m", "1", self.lofile])
        if rc != 0:
            raise OSError, "Error creating filesystem: %d" %(rc,)
        rc = subprocess.call(["/sbin/tune2fs", "-c0", "-i0", "-Odir_index",
                              "-ouser_xattr,acl", self.lofile])

    def setup(self):
        self._createSparseFile()
        self._formatFilesystem()
        return LoopbackMount.setup(self)

class LiveCDYum(yum.YumBase):
    def __init__(self):
        yum.YumBase.__init__(self)

    def doFileLogSetup(self, uid, logfile):
        # don't do the file log for the livecd as it can lead to open fds
        # being left and an inability to clean up after ourself
        pass

    def setup(self, instroot):
        self.installroot = instroot
        self.doConfigSetup(root=instroot, init_plugins = False)
        self.doGenericSetup()

        self.conf.cachedir = "/var/cache/yum"

        # don't look at the default repos from the host config
        map(lambda x: self.repos.delete(x), self.repos.repos.keys())

    def reset(self):
        self.closeRpmDB()
        self.doTsSetup()
        self.doRpmDBSetup()

    def selectPackage(self, pkg):
        """Select a given package.  Can be specified with name.arch or name*"""
        try:
            mbrs = self.install(pattern = pkg)
            return len(mbrs)
        except yum.Errors.InstallError:
            print >> sys.stderr, "No package matching %s" %(pkg,)
            return 0
        
    def deselectPackage(self, pkg):
        """Deselect package.  Can be specified as name.arch or name*"""
        sp = pkg.rsplit(".", 2)
        txmbrs = []
        if len(sp) == 2:
            txmbrs = self.tsInfo.matchNaevr(name=sp[0], arch=sp[1])

        if len(txmbrs) == 0:
            exact, match, unmatch = yum.packages.parsePackages(self.pkgSack.returnPackages(), [pkg], casematch=1)
            for p in exact + match:
                txmbrs.append(p)

        if len(txmbrs) > 0:
            map(lambda x: self.tsInfo.remove(x.pkgtup), txmbrs)
        else:
            print >> sys.stderr, "No such package %s to remove" %(pkg,)

    def selectGroup(self, grp, include = pykickstart.parser.GROUP_DEFAULT):
        yum.YumBase.selectGroup(self, grp)
        if include == pykickstart.parser.GROUP_REQUIRED:
            map(lambda p: self.deselectPackage(p), grp.default_packages.keys())
        elif include == pykickstart.parser.GROUP_ALL:
            map(lambda p: self.selectPackage(p), grp.optional_packages.keys())
        
    def addRepository(self, name, url = None, mirrorlist = None):
        repo = yum.yumRepo.YumRepository(name)
        if url:
            repo.baseurl.append(url)
        if mirrorlist:
            repo.mirrorlist = mirrorlist
        conf = yum.config.RepoConf()
        for k, v in conf.iteritems():
            if v or not hasattr(repo, k):
                repo.setAttribute(k, v)
        repo.basecachedir = self.conf.cachedir
        repo.metadata_expire = 0
        # disable gpg check???
        repo.gpgcheck = 0
        repo.enable()
        repo.setup(0)
        self.repos.add(repo)
            
    def runInstall(self):
        (res, resmsg) = self.buildTransaction()
        if res != 2:
            print "Unable to build transaction"
            for m in resmsg:
                print m
            sys.exit(1)
        
        dlpkgs = map(lambda x: x.po, filter(lambda txmbr: txmbr.ts_state in ("i", "u"), self.tsInfo.getMembers()))
        self.downloadPkgs(dlpkgs)
        # FIXME: sigcheck?
        
        self.initActionTs()
        self.populateTs(keepold=0)
        self.ts.check()
        self.ts.order()
        # FIXME: callback should be refactored a little in yum 
        sys.path.append('/usr/share/yum-cli')
        import callback
        cb = callback.RPMInstallCallback()
        cb.tsInfo = self.tsInfo
        cb.filelog = False
        return self.runTransaction(cb)

def get_kernel_version(root):
    # FIXME: this doesn't handle multiple kernels being installed
    kdir = os.listdir("%s/install_root/lib/modules" %(root,))
    kver = os.path.basename(kdir[0])
    return kver

class InstallationTarget:
    def __init__(self, repos, packages, epackages, groups, fs_label, skip_compression):
        self.ayum = LiveCDYum()
        self.repos = repos
        self.packages = packages
        self.epackages = epackages
        self.groups = groups
        self.fs_label = fs_label
        self.skip_compression = skip_compression

        self.build_dir = None
        self.instloop = None
        self.bindmounts = []
        self.ksparser = None
        
    def parse(self, kscfg):
        ksversion = pykickstart.version.makeVersion()
        self.ksparser = pykickstart.parser.KickstartParser(ksversion)
        if kscfg:
            try:
                self.ksparser.readKickstart(kscfg)
            except IOError, (err, msg):
                raise InstallationError("Failed to read kickstart file '%s' : %s" % (kscfg, msg))
            except pykickstart.errors.KickstartError, e:
                raise InstallationError("Failed to parse kickstart file '%s' : %s" % (kscfg, e))

            for repo in self.ksparser.handler.repo.repoList:
                already_given = False
                for cmd_name, cmd_url in self.repos:
                    if cmd_name == repo.name:
                        already_given = True
                        break

                if not already_given:
                    self.repos.append( (repo.name, repo.baseurl) )

            self.packages.extend(self.ksparser.handler.packages.packageList)
            self.groups.extend(map(lambda g: (g.name, g.include),
                                   self.ksparser.handler.packages.groupList))
            self.epackages.extend(self.ksparser.handler.packages.excludedList)

    def base_on_iso(self, base_on):
        """helper function to extract ext3 file system from a live CD ISO"""

        isoloop = LoopbackMount(base_on, "%s/base_on_iso" %(self.build_dir,))

        squashloop = LoopbackMount("%s/squashfs.img" %(isoloop.mountdir,),
                                   "%s/base_on_squashfs" %(self.build_dir,),
                                   "squashfs")

        try:
            if not isoloop.setup():
                raise InstallationError("Failed to loopback mount '%s'" % base_on)

            if not os.path.exists(squashloop.lofile):
                raise InstallationError("'%s' is not a valid live CD ISO : squashfs.img doesn't exist" % base_on)

            if not squashloop.setup():
                raise InstallationError("Failed to loopback mount squashfs.img from '%s'" % base_on)

            os_image = self.build_dir + "/base_on_squashfs/os.img"

            if not os.path.exists(os_image):
                raise InstallationError("'%s' is not a valid live CD ISO : os.img doesn't exist" % base_on)

            shutil.copyfile(os_image, self.build_dir + "/data/os.img")
        finally:
            # unmount and tear down the mount points and loop devices used
            squashloop.cleanup()
            isoloop.cleanup()

    def write_fstab(self):
        fstab = open(self.build_dir + "/install_root/etc/fstab", "w")
        fstab.write("/dev/mapper/livecd-rw   /                       ext3    defaults,noatime 0 0\n")
        fstab.write("devpts                  /dev/pts                devpts  gid=5,mode=620  0 0\n")
        fstab.write("tmpfs                   /dev/shm                tmpfs   defaults        0 0\n")
        fstab.write("proc                    /proc                   proc    defaults        0 0\n")
        fstab.write("sysfs                   /sys                    sysfs   defaults        0 0\n")
        fstab.close()

    def setup(self, image_size, base_on = None):
        """setup target ext3 file system in preparation for an install"""

        # setup temporary build dirs
        try:
            self.build_dir = tempfile.mkdtemp(dir="/var/tmp", prefix="livecd-creator-")
        except OSError, (err, msg):
            raise InstallationError("Failed create build directory in /var/tmp: %s" % msg)

        os.makedirs(self.build_dir + "/out/isolinux")
        os.makedirs(self.build_dir + "/out/sysroot")
        os.makedirs(self.build_dir + "/data/sysroot")
        os.makedirs(self.build_dir + "/install_root")
        os.makedirs(self.build_dir + "/yum-cache")

        if base_on:
            # get backing ext3 image if we're based this build on an existing live CD ISO
            self.base_on_iso(base_on)

            self.instloop = LoopbackMount("%s/data/os.img" %(self.build_dir,),
                                          "%s/install_root" %(self.build_dir,))
        else:
            self.instloop = SparseExt3LoopbackMount("%s/data/os.img"
                                                    %(self.build_dir,),
                                                    "%s/install_root"
                                                    %(self.build_dir,),
                                                    image_size)
            

        if not self.instloop.setup():
            raise InstallationError("Failed to loopback mount '%s'" % self.instloop.lofile)

        if not base_on:
            # create a few directories needed if it's a new image
            os.makedirs(self.build_dir + "/install_root/etc")
            os.makedirs(self.build_dir + "/install_root/boot")
            os.makedirs(self.build_dir + "/install_root/var/log")
            os.makedirs(self.build_dir + "/install_root/var/cache/yum")

        # bind mount system directories into install_root/
        for (f, dest) in [("/sys", None), ("/proc", None), ("/dev", None),
                          ("/dev/pts", None), ("/selinux", None),
                          (self.build_dir + "/yum-cache", "/var/cache/yum")]:
            b = BindChrootMount(f, self.build_dir + "/install_root", dest)

            if not b.mount():
                raise InstallationError("Cannot mount special file system '%s'" % f)

            self.bindmounts.append(b)

        # make sure /etc/mtab is current inside install_root
        os.symlink("../proc/mounts", self.build_dir + "/install_root/etc/mtab")

        self.write_fstab()

        self.ayum.setup("%s/install_root" %(self.build_dir,))

    def unmount(self):
        """detaches system bind mounts and install_root for the file system and tears down loop devices used"""
        shutil.rmtree(self.build_dir + "/yum-cache", ignore_errors=True)
        
        try:
            os.unlink(self.build_dir + "/install_root/etc/mtab")
        except OSError:
            pass

        self.bindmounts.reverse()
        for b in self.bindmounts:
            b.umount()

        if self.instloop:
            self.instloop.cleanup()
            self.instloop = None

    def teardown(self):
        if self.build_dir:
            self.unmount()
            shutil.rmtree(self.build_dir, ignore_errors = True)

    def addRepository(self, name, url):
        """adds a yum repository to temporary yum.conf file used"""
        self.ayum.addRepository(name, url)

    def run_in_root(self):
        os.chroot("%s/install_root" %(self.build_dir,))

    def installPackages(self, packageList, excludePackageList, groupList = []):
        """install packages into target file system"""
        map(lambda pkg: self.ayum.selectPackage(pkg), packageList)
        map(lambda grp: self.ayum.selectGroup(grp[0], grp[1]), groupList)
        map(lambda pkg: self.ayum.deselectPackage(pkg), excludePackageList)

        try:
            self.ayum.runInstall()
        finally:
            self.ayum.closeRpmDB()

    def configureSystem(self):
        instroot = "%s/install_root" %(self.build_dir,)
        
        # FIXME: this is a bit ugly, but with the current pykickstart
        # API, we don't really have a lot of choice.  it'd be nice to
        # be able to do something different, but so it goes

        # set up the language
        lang = self.ksparser.handler.lang.lang or "en_US.UTF-8"
        f = open("%s/etc/sysconfig/i18n" %(instroot,), "w+")
        f.write("LANG=\"%s\"\n" %(lang,))
        f.close()

        # next, the keyboard
        # FIXME: should this impact the X keyboard config too???
        # or do we want to make X be able to do this mapping
        import rhpl.keyboard
        k = rhpl.keyboard.Keyboard()
        if self.ksparser.handler.keyboard.keyboard:
            k.set(self.ksparser.handler.keyboard.keyboard)
        k.write(instroot)

        # next up is timezone
        tz = self.ksparser.handler.timezone.timezone or "America/New_York"
        utc = self.ksparser.handler.timezone.isUtc
        f = open("%s/etc/sysconfig/clock" %(instroot,), "w+")
        f.write("ZONE=\"%s\"\n" %(tz,))
        f.write("UTC=%s\n" %(utc,))
        f.close()

        # FIXME: we should handle network bits better
        f = open("%s/etc/sysconfig/network" %(instroot,), "w+")
        f.write("NETWORKING=yes\n")
        f.write("HOSTNAME=localhost.localdomain\n")
        f.close()
        f = open("/%s/etc/hosts" %(instroot,), "w+")
        f.write("127.0.0.1\t\tlocalhost.localdomain  localhost\n")
        f.write("::1\t\tlocalhost6.localdomain6 localhost6\n")        
        f.close()

        # do any authconfig bits
        auth = self.ksparser.handler.authconfig.authconfig or "--useshadow --enablemd5"
        if os.path.exists("%s/usr/sbin/authconfig" %(instroot,)):
            args = ["/usr/sbin/authconfig", "--update", "--nostart"]
            args.extend(auth.split())
            subprocess.call(args, preexec_fn=self.run_in_root)

        # firewall.  FIXME: should handle the rest of the options
        if self.ksparser.handler.firewall.enabled and os.path.exists("%s/usr/sbin/lokkit" %(instroot,)):
            subprocess.call(["/usr/sbin/lokkit", "-f", "--quiet",
                             "--nostart", "--enabled"],
                            preexec_fn=self.run_in_root)

        # selinux
        if os.path.exists("%s/usr/sbin/lokkit" %(instroot,)):
            args = ["/usr/sbin/lokkit", "-f", "--quiet", "--nostart"]
            if self.ksparser.handler.selinux.selinux:
                args.append("--selinux=enforcing")
            else:
                args.append("--selinux=disabled")
            subprocess.call(args, preexec_fn=self.run_in_root)

        # FIXME: we should allow the setting of the root pass
        if os.path.exists("%s/usr/bin/passwd" %(instroot,)):
            subprocess.call(["/usr/bin/passwd", "-d", "root"], preexec_fn=self.run_in_root)

        # enable/disable services appropriately
        if os.path.exists("%s/sbin/chkconfig" %(instroot,)):
            for s in self.ksparser.handler.services.enabled:
                subprocess.call(["/sbin/chkconfig", s, "--level", "345", "on"],
                                preexec_fn=self.run_in_root)
            for s in self.ksparser.handler.services.disabled:
                subprocess.call(["/sbin/chkconfig", s, "--level", "345", "off"],
                                preexec_fn=self.run_in_root)

        # x by default?
        if self.ksparser.handler.xconfig.startX:
            f = open("%s/etc/inittab" %(instroot,), "rw+")
            buf = f.read()
            buf = buf.replace("id:3:initdefault", "id:5:initdefault")
            f.seek(0)
            f.write(buf)
            f.close()

        # and now, for arbitrary %post scripts
        for s in filter(lambda s: s.type == pykickstart.parser.KS_SCRIPT_POST,
                        self.ksparser.handler.scripts):
            # we can only safely run scripts in the chroot
            if not s.inChroot:
                print >> sys.stderr, "Not running script outside of chroot"
                continue

            (fd, path) = tempfile.mkstemp("", "ks-script-", "%s/tmp" %(instroot,))
            os.write(fd, s.script)
            os.close(fd)
            os.chmod(path, 0700)

            subprocess.call([s.interp, "/tmp/%s" %(os.path.basename(path),)],
                            preexec_fn = self.run_in_root)
            os.unlink(path)
            

    def createInitramfs(self):
        # Create initramfs
        shutil.copy("/usr/lib/livecd-creator/mayflower",
                        "%s/install_root/sbin/mayflower" %(self.build_dir,))
        # modules needed for booting (this is butt ugly and we need to retrieve this from elsewhere, e.g. the kernel)
        mayflowerconf = open(self.build_dir + "/install_root/etc/mayflower.conf", "w")
        mayflowerconf.write('MODULES+="cdrom ide-cd ahci loop dm_snapshot squashfs ext3 ext2 ehci_hcd uhci_hcd ohci_hcd usb_storage sd_mod sr_mod usbhid ata_piix vfat msdos "\n')
        mayflowerconf.write('MODULES+="sata_mv sata_qstor sata_sis sata_uli "\n')
        mayflowerconf.write('MODULES+="sata_nv sata_sil24 sata_svw sata_via "\n')
        mayflowerconf.write('MODULES+="sata_promise sata_sil sata_sx4 sata_vsc "\n')
        mayflowerconf.write('MODULES+="ata_generic pata_ali pata_amd pata_artop pata_atiixp pata_cmd64x pata_cs5520 pata_cs5530 pata_cs5535 pata_cypress pata_efar pata_hpt366 pata_hpt37x pata_hpt3x2n pata_hpt3x3 pata_isapnp pata_it821x pata_jmicron pata_marvell pata_mpiix pata_netcell pata_ns87410 pata_oldpiix pata_optidma pata_opti pata_pcmcia pata_pdc2027x pata_pdc202xx_old pata_qdi pata_serverworks pata_sil680 pata_sis pata_sl82c105 pata_triflex pata_via pdc_adma "\n')        
        mayflowerconf.close()

        subprocess.call(["/sbin/mayflower", "-f", "/boot/livecd-initramfs.img",
                         get_kernel_version(self.build_dir)],
                        preexec_fn=self.run_in_root)
        for f in ("/sbin/mayflower", "/etc/mayflower.conf"):
            os.unlink("%s/install_root/%s" %(self.build_dir, f))

    def relabelSystem(self):
        # finally relabel all files
        if self.ksparser.handler.selinux.selinux:
            instroot = "%s/install_root" %(self.build_dir,)
            if os.path.exists("%s/sbin/restorecon" %(instroot,)):
                subprocess.call(["/sbin/restorecon", "-v", "-r", "/"],
                                preexec_fn=self.run_in_root)

    def launchShell(self):
        subprocess.call(["/bin/bash"], preexec_fn=self.run_in_root)

    def configureBootloader(self):
        """configure the boot loader"""
        
        # set up boot loader
        #
        # TODO:
        #  - fix for archs not using grub
        #  - fix for non-i386
        #  - error handling
        #
        shutil.copyfile("%s/install_root/boot/vmlinuz-%s"
                        %(self.build_dir, get_kernel_version(self.build_dir,)),
                        "%s/out/isolinux/vmlinuz" %(self.build_dir,))

        shutil.copyfile("%s/install_root/boot/livecd-initramfs.img"
                        %(self.build_dir,),
                        "%s/out/isolinux/initrd.img" %(self.build_dir,))
        os.unlink("%s/install_root/boot/livecd-initramfs.img"
                  %(self.build_dir,))

        shutil.copy("%s/install_root/usr/lib/syslinux/isolinux.bin" %(self.build_dir,),
                    "%s/out/isolinux/isolinux.bin" %(self.build_dir,))
        shutil.copy("%s/install_root/usr/lib/syslinux/vesamenu.c32" %(self.build_dir,),
                    "%s/out/isolinux/vesamenu.c32" %(self.build_dir,))

        if os.path.exists("%s/install_root/usr/lib/anaconda-runtime/syslinux-vesa-splash.jpg" %(self.build_dir,)):
            shutil.copy("%s/install_root/usr/lib/anaconda-runtime/syslinux-vesa-splash.jpg" %(self.build_dir,),
                        "%s/out/isolinux/splash.jpg" %(self.build_dir,))
            have_background = "menu background splash.jpg"
        else:
            have_background = ""

        cfg = """
default vesamenu.c32
timeout 600

%(background)s
menu title Welcome to Fedora!
menu color border 0 #ffffffff #00000000
menu color sel 0 #ffffffff #ff000000
menu color title 0 #ffffffff #00000000
menu color tabmsg 0 #ffffffff #00000000
menu color unsel 0 #ffffffff #00000000
menu color hotsel 0 #ff000000 #ffffffff
menu color hotkey 0 #ffffffff #ff000000

label linux
  menu label %(label)s
  kernel vmlinuz
  append initrd=initrd.img  ro quiet root=CDLABEL=%(label)s rootfstype=iso9660 livecd

label runfromram
  menu label %(label)s from RAM
  kernel vmlinuz
  append initrd=initrd.img ro quiet root=CDLABEL=%(label)s rootfstype=iso9660 livecd livecd_ram
""" %{"label": self.fs_label, "background" : have_background}

        cfgf = open("%s/out/isolinux/isolinux.cfg" %(self.build_dir,), "w")
        cfgf.write(cfg)
        cfgf.close()
        
        # TODO: enable external entitity to partipate in adding boot entries

    def install(self):
        for (name, url) in self.repos:
            self.ayum.addRepository(name, url)

        self.installPackages(self.packages, self.epackages, self.groups)
        self.configureSystem()
        self.relabelSystem()
        self.createInitramfs()
        self.configureBootloader()

    def createIso(self):
        """write out the live CD ISO"""
        subprocess.call(["/usr/bin/mkisofs", "-o", "%s.iso" %(self.fs_label,),
                         "-b", "isolinux/isolinux.bin",
                         "-c", "isolinux/boot.cat",
                         "-no-emul-boot", "-boot-load-size", "4",
                         "-boot-info-table", "-J", "-r", "-hide-rr-moved",
                         "-V", "%s" %(self.fs_label,), "%s/out" %(self.build_dir)])

    def createSquashFS(self):
        """create compressed squashfs file system"""
        if not self.skip_compression:
            # FIXME: mksquashfs segfaults if PWD isn't set in the environment
            subprocess.call(["/sbin/mksquashfs", "os.img", "sysroot",
                             "../out/squashfs.img"],
                            cwd="%s/data" %(self.build_dir,),
                            env={"PWD": "%s/data" %(self.build_dir,)})
        else:
            shutil.move("%s/data/os.img" %(self.build_dir,),
                        "%s/out/ext3fs.img" %(self.build_dir,))

    def package(self):
        self.createSquashFS()
        self.createIso()

def usage(out):
    print >> out, """
usage: livecd-creator [--help] 
                      [--config=<path-to-kickstart-file> | --repo=<name>,<url> --package=<p>]
                      [--repo=<name1>,<url1>] [--repo=<name2>,<url2> ...]
                      [--package=<p1>] [--package=<p2> ...]
                      [--exclude-package=<e1>] [--exclude-package=<e2> ...]
                      [--base-on=<path-to-iso-file>]
                      [--fslabel=<label>]
                      [--skip-compression]
                      [--uncompressed-size=<size-in-MB>]
                      [--shell]

 --help              : Print usage and exit
 --config            : Path to kickstart config file
 --repo              : Add / override yum repository
 --package           : Include this package
 --exclude-package   : Exclude this package
 --base-on           : Add packages to an existing live CD iso9660 image
 --fslabel           : File system label (default: livecd-YYYYMMDD-HHMI)
 --skip-compression  : Don't compress the image
 --uncompressed-size : Size of uncompressed fs in MB (default: 3072)
 --shell             : Start a shell in the chroot for post-configuration

 Examples:

  Create minimal live cd:
  # livecd-creator --config=/usr/share/livecd-tools/livecd-fedora-minimal.ks

  Create minimal live cd and use local package repositories:
  # livecd-creator --config=/usr/share/livecd-tools/livecd-fedora-minimal.ks \\
                   --repo=a-dev,file:///home/user/core/RPMS             \\
                   --repo=a-extras-dev,file:///home/user/extras/RPMS
"""

class Usage(Exception):
    def __init__(self, msg = None, no_error = False):
        Exception.__init__(self, msg, no_error)

class Options:
    def __init__(self):
        self.repos = []
        self.packages = []
        self.groups = []
        self.epackages = []
        self.fs_label = "livecd-" + time.strftime("%Y%m%d-%H%M")
        self.base_on = None
        self.kscfg = None
        self.skip_compression = False
        self.uncompressed_size = 3072
        self.give_shell = False

def parse_options(args):
    try:
        opts, args = getopt.getopt(args, "hr:b:p:e:f:c:su:l",
                                   ["help", "repo=", "base-on=", "package=",
                                    "exclude-package=", "fslabel=", "config=",
                                    "skip-compression", "uncompressed-size=",
                                    "shell"])
    except getopt.GetoptError, msg:
        raise Usage(msg)

    options = Options()

    for o, a in opts:
        if o in ("-h", "--help"):
            raise Usage(no_error = True)
        if o in ("-l", "--shell"):
            options.give_shell = True
            continue
        if o in ("-s", "--skip-compression"):
            options.skip_compression = True
            continue
        if o in ("-u", "--uncompressed-size"):
            options.uncompressed_size = int(a)
            continue
        if o in ("-c", "--config"):
            options.kscfg = a
            if not os.path.isfile(options.kscfg):
                raise Usage("Kickstart config '%s' does not exist" % options.kscfg)
            continue
        if o in ("-r", "--repo"):
            (name, url) = a.split(",")
            for (n, u) in options.repos:
                if n == name:
                    raise Usage("Repo name '%s' is already in use" % n)
            options.repos.append((name, url))
            continue
        if o in ("-p", "--package"):
            if a.startswith("@"):
                options.groups.append((a[1:], pykickstart.parser.GROUP_DEFAULT))
            else:
                options.packages.append(a)
            continue
        if o in ("-e", "--exclude-package"):
            options.epackages.append(a)
            continue
        if o in ("-f", "--fslabel"):
            options.fs_label = a
            if len(options.fs_label) > 32:
                raise Usage("CD labels are limited to 32 characters")
            continue
        if o in ("-b", "--base-on"):
            options.base_on = a
            if not os.path.isfile(options.base_on):
                raise Usage("Live CD ISO '%s' does not exist" % options.base_on)
            continue
        raise Usage("Unknown option %s" % o)

    if not options.kscfg and not (options.packages or options.groups):
        raise Usage("No packages or groups specified")

    if not options.kscfg and not options.repos:
        raise Usage("No repositories specified")

    return options

def main():
    try:
        options = parse_options(sys.argv[1:])
    except Usage, (msg, no_error):
        if no_error:
            out = sys.stdout
            ret = 0
        else:
            out = sys.stderr
            ret = 2
        if msg:
            print >> out, msg
        usage(out)
        return ret

    target = InstallationTarget(options.repos,
                                options.packages,
                                options.epackages,
                                options.groups,
                                options.fs_label,
                                options.skip_compression)

    try:
        target.parse(options.kscfg)

        target.setup(options.uncompressed_size, options.base_on)

        target.install()

        if options.give_shell:
            print "Launching shell. Exit to continue."
            print "----------------------------------"
            target.launchShell()

        target.unmount()

        target.package()
    except InstallationError, e:
        print >> sys.stderr, "Error creating Live CD : %s" % e
        return 1
    finally:
        target.teardown()

    return 0

if __name__ == "__main__":
    sys.exit(main())
