#!/usr/bin/python -tt
#
# livecd-creator : Creates Live CD based for Fedora.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

import getopt
import os
import os.path
import sys
import tempfile
import time
import traceback
import subprocess
import shutil
import yum
import pykickstart.parser
import pykickstart.version

class BindChrootMount:
    """Represents a bind mount of a directory into a chroot."""
    def __init__(self, src, chroot, dest = None):
        self.src = src
        self.root = chroot
        if dest:
            self.dest = dest
        else:
            self.dest = src

        self.mounted = False

    def mount(self):
        if not self.mounted:
            if not os.path.exists("%s/%s" %(self.root, self.dest)):
                os.makedirs("%s/%s" %(self.root, self.dest))
            rc = subprocess.call(["/bin/mount", "--bind", self.src,
                                  "%s/%s" %(self.root, self.dest)])
            if rc == 0:
                self.mounted = True
        return self.mounted

    def umount(self):
        if self.mounted:
            rc = subprocess.call(["/bin/umount",
                                  "%s/%s" %(self.root, self.dest)])
            self.mounted = False
        

class LoopbackMount:
    def __init__(self, lofile, mountdir, fstype = None):
        self.lofile = lofile
        self.mountdir = mountdir
        self.fstype = fstype

        self.mounted = False
        self.losetup = False
        self.loopdev = None

    def cleanup(self, rmdir = True):
        self.umount()
        self.lounsetup()
        if rmdir:
            try:
                os.rmdir(self.mountdir)
            except OSError, e:
                pass

    def umount(self):
        if self.mounted:
            rc = subprocess.call(["/bin/umount", self.mountdir])
            self.mounted = False

    def lounsetup(self):
        if self.losetup and self.loopdev:
            rc = subprocess.call(["/sbin/losetup", "-d", self.loopdev])
            self.losetup = False
            self.loopdev = None

    def setup(self):
        if not os.path.exists(self.mountdir):
            os.makedirs(self.mountdir)
        if self.loopsetup():
            if self.mount():
                return True
        return False

    def loopsetup(self):
        if self.losetup:
            return self.losetup
        rc = subprocess.call(["/sbin/losetup", "-f", self.lofile])
        if rc != 0:
            return self.losetup

        # succeeded; figure out which loopdevice we're using
        buf = subprocess.Popen(["/sbin/losetup", "-a"],
                               stdout=subprocess.PIPE).communicate()[0]
        for line in buf.split("\n"):
            # loopdev: fdinfo (filename)
            fields = line.split()
            if len(fields) != 3:
                continue
            if fields[2] == "(%s)" %(self.lofile,):
                self.loopdev = fields[0][:-1]
                break

        if self.loopdev:
            self.losetup = True
        return self.losetup

    def mount(self):
        if self.mounted or not self.loopdev:
            return self.mounted
        args = [ "/bin/mount", self.loopdev, self.mountdir ]
        if self.fstype:
            args.extend(["-t", self.fstype])
        rc = subprocess.call(args)
        if rc == 0:
            self.mounted = True
        return self.mounted

class SparseExt3LoopbackMount(LoopbackMount):
    def __init__(self, lofile, mountdir, size, fslabel = None):
        LoopbackMount.__init__(self, lofile, mountdir, fstype = "ext3")
        self.size = size
        self.fslabel = fslabel
        if not self.fslabel:
            self.fslabel = "livecd-" + time.strftime("%Y%m%d-%H%M")

    def _createSparseFile(self):
        dir = os.path.dirname(self.lofile)
        if not dir:
            os.makedirs(dir)

        # create the sparse file
        fd = os.open(self.lofile, os.O_WRONLY | os.O_CREAT)
        off = long(self.size * 1024L * 1024L)
        os.lseek(fd, off, 0)
        os.write(fd, '\x00')
        os.close(fd)

    def _formatFilesystem(self):
        rc = subprocess.call(["/sbin/mkfs.ext3", "-F", "-L", self.fslabel,
                              "-m", "1", self.lofile])
        if rc != 0:
            raise OSError, "Error creating filesystem: %d" %(rc,)
        rc = subprocess.call(["/sbin/tune2fs", "-c0", "-i0", "-Odir_index",
                              "-ouser_xattr,acl", self.lofile])

    def setup(self):
        self._createSparseFile()
        self._formatFilesystem()
        return LoopbackMount.setup(self)

class LiveCDYum(yum.YumBase):
    def __init__(self):
        yum.YumBase.__init__(self)

    def doFileLogSetup(self, uid, logfile):
        # don't do the file log for the livecd as it can lead to open fds
        # being left and an inability to clean up after ourself
        pass

    def setup(self, instroot):
        self.installroot = instroot
        self.doConfigSetup(root=instroot, init_plugins = False)
        self.doGenericSetup()

        self.conf.cachedir = "/var/cache/yum"

        # don't look at the default repos from the host config
        map(lambda x: self.repos.delete(x), self.repos.repos.keys())

    def reset(self):
        self.closeRpmDB()
        self.doTsSetup()
        self.doRpmDBSetup()

    def selectPackage(self, pkg):
        """Select a given package.  Can be specified with name.arch or name*"""
        try:
            mbrs = self.install(pattern = pkg)
            return len(mbrs)
        except yum.Errors.InstallError:
            print >> sys.stderr, "No package matching %s" %(pkg,)
            return 0
        
    def deselectPackage(self, pkg):
        """Deselect package.  Can be specified as name.arch or name*"""
        sp = pkg.rsplit(".", 2)
        txmbrs = []
        if len(sp) == 2:
            txmbrs = self.tsInfo.matchNaevr(name=sp[0], arch=sp[1])

        if len(txmbrs) == 0:
            exact, match, unmatch = yum.packages.parsePackages(self.pkgSack.returnPackages(), [pkg], casematch=1)
            for p in exact + match:
                txmbrs.append(p)

        if len(txmbrs) > 0:
            map(lambda x: self.tsInfo.remove(x.pkgtup), txmbrs)
        else:
            print >> sys.stderr, "No such package %s to remove" %(pkg,)

    def selectGroup(self, grp, include = pykickstart.parser.GROUP_DEFAULT):
        yum.YumBase.selectGroup(self, grp)
        if include == pykickstart.parser.GROUP_REQUIRED:
            map(lambda p: self.deselectPackage(p), grp.default_packages.keys())
        elif include == pykickstart.parser.GROUP_ALL:
            map(lambda p: self.selectPackage(p), grp.optional_packages.keys())
        
    def addRepository(self, name, url = None, mirrorlist = None):
        repo = yum.yumRepo.YumRepository(name)
        if url:
            repo.baseurl.append(url)
        if mirrorlist:
            repo.mirrorlist = mirrorlist
        conf = yum.config.RepoConf()
        for k, v in conf.iteritems():
            if v or not hasattr(repo, k):
                repo.setAttribute(k, v)
        repo.basecachedir = self.conf.cachedir
        repo.metadata_expire = 0
        # disable gpg check???
        repo.gpgcheck = 0
        repo.enable()
        repo.setup(0)
        self.repos.add(repo)
            
    def runInstall(self):
        (res, resmsg) = self.buildTransaction()
        if res != 2:
            print "Unable to build transaction"
            for m in resmsg:
                print m
            sys.exit(1)
        
        dlpkgs = map(lambda x: x.po, filter(lambda txmbr: txmbr.ts_state in ("i", "u"), self.tsInfo.getMembers()))
        self.downloadPkgs(dlpkgs)
        # FIXME: sigcheck?
        
        self.initActionTs()
        self.populateTs(keepold=0)
        self.ts.check()
        self.ts.order()
        # FIXME: callback should be refactored a little in yum 
        sys.path.append('/usr/share/yum-cli')
        import callback
        cb = callback.RPMInstallCallback()
        cb.tsInfo = self.tsInfo
        cb.filelog = False
        return self.runTransaction(cb)

def get_kernel_version(root):
    # FIXME: this doesn't handle multiple kernels being installed
    kdir = os.listdir("%s/install_root/lib/modules" %(root,))
    kver = os.path.basename(kdir[0])
    return kver

class InstallationTarget:
    def __init__(self, repos, packages, epackages, groups, fs_label, skip_compression):
        self.ayum = LiveCDYum()
        self.repos = repos
        self.packages = packages
        self.epackages = epackages
        self.groups = groups
        self.fs_label = fs_label
        self.skip_compression = skip_compression

        self.build_dir = None
        self.instloop = None
        self.bindmounts = []
        self.ksparser = None
        
    def parse(self, kscfg):
        ksversion = pykickstart.version.makeVersion()
        self.ksparser = pykickstart.parser.KickstartParser(ksversion)
        if kscfg:
            self.ksparser.readKickstart(kscfg)

            for repo in self.ksparser.handler.repo.repoList:
                already_given = False
                for cmd_name, cmd_url in self.repos:
                    if cmd_name == repo.name:
                        already_given = True
                        break

                if not already_given:
                    self.repos.append( (repo.name, repo.baseurl) )

            self.packages.extend(self.ksparser.handler.packages.packageList)
            self.groups.extend(map(lambda g: (g.name, g.include),
                                   self.ksparser.handler.packages.groupList))
            self.epackages.extend(self.ksparser.handler.packages.excludedList)

    def base_on_iso(self, base_on):
        """helper function to extract ext3 file system from a live CD ISO"""

        isoloop = LoopbackMount(base_on, "%s/base_on_iso" %(self.build_dir,))

        squashloop = LoopbackMount("%s/squashfs.img" %(isoloop.mountdir,),
                                   "%s/base_on_squashfs" %(self.build_dir,),
                                   "squashfs")

        success = False
        try:
            if isoloop.setup() and squashloop.setup():
                # copy the ext3 fs out
                try:
                    shutil.copyfile("%s/base_on_squashfs/os.img" %(self.build_dir,),
                                    "%s/data/os.img" %(self.build_dir,))
                    success = True
                except Exception, e:
                    print "Cannot copy os.img from squashfs from ISO to base on"
                    traceback.print_exc(file=sys.stderr)
        finally:
            # unmount and tear down the mount points and loop devices used
            squashloop.cleanup()
            isoloop.cleanup()

        return success


    def setup(self, image_size, base_on = None):
        """setup target ext3 file system in preparation for an install"""

        # setup temporary build dirs
        try:
            self.build_dir = tempfile.mkdtemp(dir="/var/tmp", prefix="livecd-creator-")
        except OSError, e:
            print "Cannot create build directory in /var/tmp: %s" % e
            return False

        try:
            os.mkdir(self.build_dir + "/out")
            os.mkdir(self.build_dir + "/out/isolinux")
            os.mkdir(self.build_dir + "/out/sysroot")
            os.mkdir(self.build_dir + "/data")
            os.mkdir(self.build_dir + "/data/sysroot")            
            os.mkdir(self.build_dir + "/install_root")
            os.mkdir(self.build_dir + "/yum-cache")
        except OSError:
            print "Cannot create directory"
            self.teardown()
            return False

        if base_on:
            # get backing ext3 image if we're based this build on an existing live CD ISO
            if not self.base_on_iso(base_on):
                self.teardown()
                return False
            self.instloop = LoopbackMount("%s/data/os.img" %(self.build_dir,),
                                          "%s/install_root" %(self.build_dir,))
        else:
            self.instloop = SparseExt3LoopbackMount("%s/data/os.img"
                                                    %(self.build_dir,),
                                                    "%s/install_root"
                                                    %(self.build_dir,),
                                                    image_size)
            

        if not self.instloop.setup():
            self.teardown()
            return False

        if not base_on:
            # create a few directories needed if it's a new image
            try:
                os.mkdir(self.build_dir + "/install_root/etc")
                os.mkdir(self.build_dir + "/install_root/boot")
                os.mkdir(self.build_dir + "/install_root/var")
                os.mkdir(self.build_dir + "/install_root/var/log")
                os.mkdir(self.build_dir + "/install_root/var/cache")
                os.mkdir(self.build_dir + "/install_root/var/cache/yum")
            except OSError:
                print "Cannot create directory"
                self.teardown()
                return False

        # bind mount system directories into install_root/
        for f in ["/sys", "/proc", "/dev", "/dev/pts", "/selinux"]:
            b = BindChrootMount(f, "%s/install_root" %(self.build_dir,))
            if b.mount():
                self.bindmounts.append(b)
            else:
                print "Cannot mount special file system %s"%f
                self.teardown()
                return False

        # make sure /etc/mtab is current inside install_root
        try:
            os.symlink("../proc/mounts", self.build_dir + "/install_root/etc/mtab")
        except OSError:
            print "Cannot create symlink %s/etc/mtab -> ../proc/mounts"%(self.build_dir)
            self.teardown()
            return False

        # write an /etc/fstab file
        fstab = open(self.build_dir + "/install_root/etc/fstab", "w")
        fstab.write("/dev/mapper/livecd-rw   /                       ext3    defaults,noatime 0 0\n")
        fstab.write("devpts                  /dev/pts                devpts  gid=5,mode=620  0 0\n")
        fstab.write("tmpfs                   /dev/shm                tmpfs   defaults        0 0\n")
        fstab.write("proc                    /proc                   proc    defaults        0 0\n")
        fstab.write("sysfs                   /sys                    sysfs   defaults        0 0\n")
        fstab.close()

        b = BindChrootMount("%s/yum-cache" %(self.build_dir,),
                            "%s/install_root" %(self.build_dir,),
                            "/var/cache/yum")
        if b.mount():
            self.bindmounts.append(b)
        else:
            print "Cannot bind mount /var/cache/yum"
            self.teardown()
            return False

        self.ayum.setup("%s/install_root" %(self.build_dir,))
        return True


    def unmount(self):
        """detaches system bind mounts and install_root for the file system and tears down loop devices used"""
        shutil.rmtree(self.build_dir + "/yum-cache", ignore_errors=True)
        
        try:
            os.unlink(self.build_dir + "/install_root/etc/mtab")
        except OSError:
            pass

        self.bindmounts.reverse()
        for b in self.bindmounts:
            b.umount()

        if self.instloop:
            self.instloop.cleanup()
            self.instloop = None

    def teardown(self):
        if self.build_dir:
            self.unmount()
            shutil.rmtree(self.build_dir, ignore_errors = True)

    def addRepository(self, name, url):
        """adds a yum repository to temporary yum.conf file used"""
        self.ayum.addRepository(name, url)

    def run_in_root(self):
        os.chroot("%s/install_root" %(self.build_dir,))

    def installPackages(self, packageList, excludePackageList, groupList = []):
        """install packages into target file system"""
        map(lambda pkg: self.ayum.selectPackage(pkg), packageList)
        map(lambda grp: self.ayum.selectGroup(grp[0], grp[1]), groupList)
        map(lambda pkg: self.ayum.deselectPackage(pkg), excludePackageList)

        try:
            self.ayum.runInstall()
        except Exception, e:
            print "Error installing packages"
            traceback.print_exc(file=sys.stderr)
            self.ayum.closeRpmDB()            
            return False
        self.ayum.closeRpmDB()
        return True

    def configureSystem(self, ksparser):
        instroot = "%s/install_root" %(self.build_dir,)
        
        # FIXME: this is a bit ugly, but with the current pykickstart
        # API, we don't really have a lot of choice.  it'd be nice to
        # be able to do something different, but so it goes

        # set up the language
        lang = ksparser.handler.lang.lang or "en_US.UTF-8"
        f = open("%s/etc/sysconfig/i18n" %(instroot,), "w+")
        f.write("LANG=\"%s\"\n" %(lang,))
        f.close()

        # next, the keyboard
        # FIXME: should this impact the X keyboard config too???
        # or do we want to make X be able to do this mapping
        import rhpl.keyboard
        k = rhpl.keyboard.Keyboard()
        if ksparser.handler.keyboard.keyboard:
            k.set(ksparser.handler.keyboard.keyboard)
        k.write(instroot)

        # next up is timezone
        tz = ksparser.handler.timezone.timezone or "America/New_York"
        utc = ksparser.handler.timezone.isUtc
        f = open("%s/etc/sysconfig/clock" %(instroot,), "w+")
        f.write("ZONE=\"%s\"\n" %(tz,))
        f.write("UTC=%s\n" %(utc,))
        f.close()

        # FIXME: we should handle network bits better
        f = open("%s/etc/sysconfig/network" %(instroot,), "w+")
        f.write("NETWORKING=yes\n")
        f.write("HOSTNAME=localhost.localdomain\n")
        f.close()
        f = open("/%s/etc/hosts" %(instroot,), "w+")
        f.write("127.0.0.1\t\tlocalhost.localdomain  localhost\n")
        f.write("::1\t\tlocalhost6.localdomain6 localhost6\n")        
        f.close()

        # do any authconfig bits
        auth = ksparser.handler.authconfig.authconfig or "--useshadow --enablemd5"
        if os.path.exists("%s/usr/sbin/authconfig" %(instroot,)):
            args = ["/usr/sbin/authconfig", "--update", "--nostart"]
            args.extend(auth.split())
            subprocess.call(args, preexec_fn=self.run_in_root)

        # firewall.  FIXME: should handle the rest of the options
        if ksparser.handler.firewall.enabled and os.path.exists("%s/usr/sbin/lokkit" %(instroot,)):
            subprocess.call(["/usr/sbin/lokkit", "-f", "--quiet",
                             "--nostart", "--enabled"],
                            preexec_fn=self.run_in_root)

        # selinux
        if os.path.exists("%s/usr/sbin/lokkit" %(instroot,)):
            args = ["/usr/sbin/lokkit", "-f", "--quiet", "--nostart"]
            if ksparser.handler.selinux.selinux:
                args.append("--selinux=enforcing")
            else:
                args.append("--selinux=disabled")
            subprocess.call(args, preexec_fn=self.run_in_root)

        # FIXME: we should allow the setting of the root pass
        if os.path.exists("%s/usr/bin/passwd" %(instroot,)):
            subprocess.call(["/usr/bin/passwd", "-d", "root"], preexec_fn=self.run_in_root)

        # enable/disable services appropriately
        if os.path.exists("%s/sbin/chkconfig" %(instroot,)):
            for s in ksparser.handler.services.enabled:
                subprocess.call(["/sbin/chkconfig", s, "--level", "345", "on"],
                                preexec_fn=self.run_in_root)
            for s in ksparser.handler.services.disabled:
                subprocess.call(["/sbin/chkconfig", s, "--level", "345", "off"],
                                preexec_fn=self.run_in_root)

        # x by default?
        if ksparser.handler.xconfig.startX:
            f = open("%s/etc/inittab" %(instroot,), "rw+")
            buf = f.read()
            buf = buf.replace("id:3:initdefault", "id:5:initdefault")
            f.seek(0)
            f.write(buf)
            f.close()

        # and now, for arbitrary %post scripts
        for s in filter(lambda s: s.type == pykickstart.parser.KS_SCRIPT_POST,
                        ksparser.handler.scripts):
            # we can only safely run scripts in the chroot
            if not s.inChroot:
                print >> sys.stderr, "Not running script outside of chroot"
                continue

            (fd, path) = tempfile.mkstemp("", "ks-script-", "%s/tmp" %(instroot,))
            os.write(fd, s.script)
            os.close(fd)
            os.chmod(path, 0700)

            subprocess.call([s.interp, "/tmp/%s" %(os.path.basename(path),)],
                            preexec_fn = self.run_in_root)
            os.unlink(path)
            

    def createInitramfs(self):
        # Create initramfs
        shutil.copy("/usr/lib/livecd-creator/mayflower",
                        "%s/install_root/sbin/mayflower" %(self.build_dir,))
        # modules needed for booting (this is butt ugly and we need to retrieve this from elsewhere, e.g. the kernel)
        mayflowerconf = open(self.build_dir + "/install_root/etc/mayflower.conf", "w")
        mayflowerconf.write('MODULES+="cdrom ide-cd ahci loop dm_snapshot squashfs ext3 ext2 ehci_hcd uhci_hcd ohci_hcd usb_storage sd_mod sr_mod usbhid ata_piix vfat msdos "\n')
        mayflowerconf.write('MODULES+="sata_mv sata_qstor sata_sis sata_uli "\n')
        mayflowerconf.write('MODULES+="sata_nv sata_sil24 sata_svw sata_via "\n')
        mayflowerconf.write('MODULES+="sata_promise sata_sil sata_sx4 sata_vsc "\n')
        mayflowerconf.write('MODULES+="ata_generic pata_ali pata_amd pata_artop pata_atiixp pata_cmd64x pata_cs5520 pata_cs5530 pata_cs5535 pata_cypress pata_efar pata_hpt366 pata_hpt37x pata_hpt3x2n pata_hpt3x3 pata_isapnp pata_it821x pata_jmicron pata_marvell pata_mpiix pata_netcell pata_ns87410 pata_oldpiix pata_optidma pata_opti pata_pcmcia pata_pdc2027x pata_pdc202xx_old pata_qdi pata_serverworks pata_sil680 pata_sis pata_sl82c105 pata_triflex pata_via pdc_adma "\n')        
        mayflowerconf.close()

        subprocess.call(["/sbin/mayflower", "-f", "/boot/livecd-initramfs.img",
                         get_kernel_version(self.build_dir)],
                        preexec_fn=self.run_in_root)
        for f in ("/sbin/mayflower", "/etc/mayflower.conf"):
            os.unlink("%s/install_root/%s" %(self.build_dir, f))

    def relabelSystem(self):
        # finally relabel all files
        if self.ksparser.handler.selinux.selinux:
            instroot = "%s/install_root" %(self.build_dir,)
            if os.path.exists("%s/sbin/restorecon" %(instroot,)):
                subprocess.call(["/sbin/restorecon", "-v", "-r", "/"],
                                preexec_fn=self.run_in_root)

    def launchShell(self):
        print "Launching shell. Exit to continue."
        print "----------------------------------"
        subprocess.call(["/bin/bash"], preexec_fn=self.run_in_root)
        return True

    def configureBootloader(self):
        """configure the boot loader"""
        
        # set up boot loader
        #
        # TODO:
        #  - fix for archs not using grub
        #  - fix for non-i386
        #  - error handling
        #
        shutil.copyfile("%s/install_root/boot/vmlinuz-%s"
                        %(self.build_dir, get_kernel_version(self.build_dir,)),
                        "%s/out/isolinux/vmlinuz" %(self.build_dir,))

        shutil.copyfile("%s/install_root/boot/livecd-initramfs.img"
                        %(self.build_dir,),
                        "%s/out/isolinux/initrd.img" %(self.build_dir,))
        os.unlink("%s/install_root/boot/livecd-initramfs.img"
                  %(self.build_dir,))

        shutil.copy("%s/install_root/usr/lib/syslinux/isolinux.bin" %(self.build_dir,),
                    "%s/out/isolinux/isolinux.bin" %(self.build_dir,))
        shutil.copy("%s/install_root/usr/lib/syslinux/vesamenu.c32" %(self.build_dir,),
                    "%s/out/isolinux/vesamenu.c32" %(self.build_dir,))

        if os.path.exists("%s/install_root/usr/lib/anaconda-runtime/syslinux-vesa-splash.jpg" %(self.build_dir,)):
            shutil.copy("%s/install_root/usr/lib/anaconda-runtime/syslinux-vesa-splash.jpg" %(self.build_dir,),
                        "%s/out/isolinux/splash.jpg" %(self.build_dir,))
            have_background = "menu background splash.jpg"
        else:
            have_background = ""

        cfg = """
default vesamenu.c32
timeout 600

%(background)s
menu title Welcome to Fedora!
menu color border 0 #ffffffff #00000000
menu color sel 0 #ffffffff #ff000000
menu color title 0 #ffffffff #00000000
menu color tabmsg 0 #ffffffff #00000000
menu color unsel 0 #ffffffff #00000000
menu color hotsel 0 #ff000000 #ffffffff
menu color hotkey 0 #ffffffff #ff000000

label linux
  menu label %(label)s
  kernel vmlinuz
  append initrd=initrd.img  ro quiet root=CDLABEL=%(label)s rootfstype=iso9660 livecd

label runfromram
  menu label %(label)s from RAM
  kernel vmlinuz
  append initrd=initrd.img ro quiet root=CDLABEL=%(label)s rootfstype=iso9660 livecd livecd_ram
""" %{"label": self.fs_label, "background" : have_background}

        cfgf = open("%s/out/isolinux/isolinux.cfg" %(self.build_dir,), "w")
        cfgf.write(cfg)
        cfgf.close()
        
        # TODO: enable external entitity to partipate in adding boot entries

    def install(self):
        for (name, url) in self.repos:
            self.ayum.addRepository(name, url)

        if not self.installPackages(self.packages, self.epackages, self.groups):
            self.teardown()
            sys.exit(1)

        self.configureSystem(self.ksparser)
        self.relabelSystem()
        self.createInitramfs()
        self.configureBootloader()

    def createIso(self, filename):
        """write out the live CD ISO"""
        subprocess.call(["/usr/bin/mkisofs", "-o", "%s.iso" %(filename,),
                         "-b", "isolinux/isolinux.bin",
                         "-c", "isolinux/boot.cat",
                         "-no-emul-boot", "-boot-load-size", "4",
                         "-boot-info-table", "-J", "-r", "-hide-rr-moved",
                         "-V", "%s" %(filename,), "%s/out" %(self.build_dir)])

    def createSquashFS(self):
        """create compressed squashfs file system"""
        if not self.skip_compression:
            # FIXME: mksquashfs segfaults if PWD isn't set in the environment
            subprocess.call(["/sbin/mksquashfs", "os.img", "sysroot",
                             "../out/squashfs.img"],
                            cwd="%s/data" %(self.build_dir,),
                            env={"PWD": "%s/data" %(self.build_dir,)})
        else:
            shutil.move("%s/data/os.img" %(self.build_dir,),
                        "%s/out/ext3fs.img" %(self.build_dir,))

    def package(self):
        self.createSquashFS()
        self.createIso(self.fs_label)

def usage():
    print """
usage: livecd-creator [--help] 
                      [--config=<path-to-kickstart-file> | --repo=<name>,<url> --package=<p>]
                      [--repo=<name1>,<url1>] [--repo=<name2>,<url2> ...]
                      [--package=<p1>] [--package=<p2> ...]
                      [--exclude-package=<e1>] [--exclude-package=<e2> ...]
                      [--base-on=<path-to-iso-file>]
                      [--fslabel=<label>]
                      [--skip-compression]
                      [--uncompressed-size=<size-in-MB>]
                      [--shell]

 --help              : Print usage and exit
 --config            : Path to kickstart config file
 --repo              : Add / override yum repository
 --package           : Include this package
 --exclude-package   : Exclude this package
 --base-on           : Add packages to an existing live CD iso9660 image
 --fslabel           : File system label (default: livecd-YYYYMMDD-HHMI)
 --skip-compression  : Don't compress the image
 --uncompressed-size : Size of uncompressed fs in MB (default: 3072)
 --shell             : Start a shell in the chroot for post-configuration

 Examples:

  Create minimal live cd:
  # livecd-creator --config=/usr/share/livecd-tools/livecd-fedora-minimal.ks

  Create minimal live cd and use local package repositories:
  # livecd-creator --config=/usr/share/livecd-tools/livecd-fedora-minimal.ks \\
                   --repo=a-dev,file:///home/user/core/RPMS             \\
                   --repo=a-extras-dev,file:///home/user/extras/RPMS
"""

def main():

    repos = []
    packages = []
    groups = []
    epackages = []
    fs_label = "livecd-" + time.strftime("%Y%m%d-%H%M")
    base_on = None
    kscfg = None
    skip_compression = False
    uncompressed_size = 3072
    give_shell = False

    try:
        opts, args = getopt.getopt(sys.argv[1:], "hr:b:p:e:f:c:su:l",
                                   ["help", "repo=", "base-on=", "package=",
                                    "exclude-package=", "fslabel=", "config=",
                                    "skip-compression", "uncompressed-size=",
                                    "shell"])
    except getopt.GetoptError:
        usage()
        sys.exit(2)
    output = None
    verbose = False
    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
            sys.exit(0)
        if o in ("-l", "--shell"):
            give_shell = True
            continue
        if o in ("-s", "--skip-compression"):
            skip_compression = True
            continue
        if o in ("-u", "--uncompressed-size"):
            uncompressed_size = int(a)
            continue
        if o in ("-c", "--config"):
            kscfg = a
            continue
        if o in ("-r", "--repo"):
            (name, url) = a.split(",")
            for (n, u) in repos:
                if n == name:
                    print "Repo name '%s' is already in use"%n
                    sys.exit(2)
            repos.append((name, url))
            continue
        if o in ("-p", "--package"):
            if a.startswith("@"):
                groups.append((a[1:], pykickstart.parser.GROUP_DEFAULT))
            else:
                packages.append(a)
            continue
        if o in ("-e", "--exclude-package"):
            epackages.append(a)
            continue
        if o in ("-f", "--fslabel"):
            fs_label = a
            if len(fs_label) > 32:
                print "CD labels are limited to 32 characters"
                sys.exit(2)
            continue
        if o in ("-b", "--base-on"):
            base_on = a
            continue
        print "Unknown option %s"%o
        sys.exit(2)

    if not kscfg and not (packages or groups):
        print "No packages or groups specified."
        print ""
        usage()
        sys.exit(1)

    if not kscfg and not repos:
        print "No repositories specified."
        print ""
        usage()
        sys.exit(1)

    target = InstallationTarget(repos, packages, epackages, groups, fs_label, skip_compression)

    target.parse(kscfg)

    if not target.setup(uncompressed_size, base_on):
        print "Cannot setup installation target. Aborting."
        sys.exit(1)

    try:
        target.install()
    except SystemExit:
        sys.exit(1)
    except:
        print "\n\nERROR during installation..."
        traceback.print_exc(file=sys.stderr)
        target.teardown()
        sys.exit(1)

    
    if give_shell:
        target.launchShell()

    target.unmount()
    target.package()
    target.teardown()

if __name__ == "__main__":
    main()
