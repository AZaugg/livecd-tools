#!/usr/bin/python -tt
#
# livecd-creator : Creates Live CD based for Fedora.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

import getopt
import os
import os.path
import sys
import tempfile
import time
import subprocess
import shutil

class BindChrootMount:
    """Represents a bind mount of a directory into a chroot."""
    def __init__(self, src, chroot, dest = None):
        self.src = src
        self.root = chroot
        if dest:
            self.dest = dest
        else:
            self.dest = src

        self.mounted = False

    def mount(self):
        if not self.mounted:
            if not os.path.exists("%s/%s" %(self.root, self.dest)):
                os.makedirs("%s/%s" %(self.root, self.dest))
            rc = subprocess.call(["/bin/mount", "--bind", self.src,
                                  "%s/%s" %(self.root, self.dest)])
            if rc == 0:
                self.mounted = True
        return self.mounted

    def umount(self):
        if self.mounted:
            rc = subprocess.call(["/bin/umount",
                                  "%s/%s" %(self.root, self.dest)])
            self.mounted = False
        

class LoopbackMount:
    def __init__(self, lofile, mountdir, fstype = None):
        self.lofile = lofile
        self.mountdir = mountdir
        self.fstype = fstype

        self.mounted = False
        self.losetup = False
        self.loopdev = None

    def cleanup(self, rmdir = True):
        self.umount()
        self.lounsetup()
        if rmdir:
            try:
                os.rmdir(self.mountdir)
            except OSError, e:
                pass

    def umount(self):
        if self.mounted:
            rc = subprocess.call(["/bin/umount", self.mountdir])
            self.mounted = False

    def lounsetup(self):
        if self.losetup and self.loopdev:
            rc = subprocess.call(["/sbin/losetup", "-d", self.loopdev])
            self.losetup = False
            self.loopdev = None

    def setup(self):
        if not os.path.exists(self.mountdir):
            os.makedirs(self.mountdir)
        if self.loopsetup():
            if self.mount():
                return True
        return False

    def loopsetup(self):
        if self.losetup:
            return self.losetup
        rc = subprocess.call(["/sbin/losetup", "-f", self.lofile])
        if rc != 0:
            return self.losetup

        # succeeded; figure out which loopdevice we're using
        buf = subprocess.Popen(["/sbin/losetup", "-a"],
                               stdout=subprocess.PIPE).communicate()[0]
        for line in buf.split("\n"):
            # loopdev: fdinfo (filename)
            fields = line.split()
            if len(fields) != 3:
                continue
            if fields[2] == "(%s)" %(self.lofile,):
                self.loopdev = fields[0][:-1]
                break

        if self.loopdev:
            self.losetup = True
        return self.losetup

    def mount(self):
        if self.mounted or not self.loopdev:
            return self.mounted
        args = [ "/bin/mount", self.loopdev, self.mountdir ]
        if self.fstype:
            args.extend(["-t", self.fstype])
        rc = subprocess.call(args)
        if rc == 0:
            self.mounted = True
        return self.mounted

class SparseExt3LoopbackMount(LoopbackMount):
    def __init__(self, lofile, mountdir, size, fslabel = None):
        LoopbackMount.__init__(self, lofile, mountdir, fstype = "ext3")
        self.size = size
        self.fslabel = fslabel
        if not self.fslabel:
            self.fslabel = "livecd-" + time.strftime("%Y%m%d-%H%M")

    def _createSparseFile(self):
        dir = os.path.dirname(self.lofile)
        if not dir:
            os.makedirs(dir)

        # create the sparse file
        fd = os.open(self.lofile, os.O_WRONLY | os.O_CREAT)
        off = long(self.size * 1024L * 1024L)
        os.lseek(fd, off, 0)
        os.write(fd, '\x00')
        os.close(fd)

    def _formatFilesystem(self):
        rc = subprocess.call(["/sbin/mkfs.ext3", "-F", "-L", self.fslabel,
                              "-m", "1", self.lofile])
        if rc != 0:
            raise OSError, "Error creating filesystem: %d" %(rc,)
        rc = subprocess.call(["/sbin/tune2fs", "-c0", "-i0", "-Odir_index",
                              "-ouser_xattr,acl", self.lofile])

    def setup(self):
        self._createSparseFile()
        self._formatFilesystem()
        return LoopbackMount.setup(self)

def touch(fn):
    f = open(fn, "w+")
    f.close()

def get_kernel_version(root):
    # FIXME: this doesn't handle multiple kernels being installed
    kdir = os.listdir("%s/install_root/lib/modules" %(root,))
    kver = os.path.basename(kdir[0])
    return kver

class InstallationTarget:
    def base_on_iso(self, base_on):
        """helper function to extract ext3 file system from a live CD ISO"""

        isoloop = LoopbackMount(base_on, "%s/base_on_iso" %(self.build_dir,))
        if not isoloop.setup():
            isoloop.cleanup()
            return False

        squashloop = LoopbackMount("%s/squashfs.img" %(isoloop.mountdir,),
                                   "%s/base_on_squashfs" %(self.build_dir,),
                                   "squashfs")
        if not squashloop.setup():
            squashloop.cleanup()
            isoloop.cleanup()
            return False

        # copy the ext3 fs out
        try:
            shutil.copyfile("%s/base_on_squashfs/os.img" %(self.build_dir,),
                            "%s/data/os.img" %(self.build_dir,))
        except Exception, e:
            print "Cannot copy os.img from squashfs from ISO to base on: %s" %(e,)
            squashloop.cleanup()
            isoloop.cleanup()
            return False

        # unmount and tear down the mount points and loop devices used
        squashloop.cleanup()
        isoloop.cleanup()
        return True


    def setup(self, image_size, fs_label, base_on):
        """setup target ext3 file system in preparation for an install"""

        # global variables needed
        self.fs_label = fs_label
        self.instloop = None
        self.bindmounts = []

        # setup temporary build dirs
        self.build_dir = "/var/tmp/livecd-creator/build-" + os.path.basename(tempfile.mktemp())
        try:
            os.makedirs(self.build_dir)
        except OSError:
            print "Cannot create build directory at %s"
            return False

        try:
            os.mkdir(self.build_dir + "/out")
            os.mkdir(self.build_dir + "/out/isolinux")
            os.mkdir(self.build_dir + "/out/sysroot")
            os.mkdir(self.build_dir + "/data")
            os.mkdir(self.build_dir + "/data/sysroot")
            os.mkdir(self.build_dir + "/install_root")
            os.mkdir(self.build_dir + "/yum-cache")
        except OSError:
            print "Cannot create directory"
            self.teardown()
            return False

        if base_on != "":
            # get backing ext3 image if we're based this build on an existing live CD ISO
            if not self.base_on_iso(base_on):
                self.teardown()
                return False
            self.instloop = LoopbackMount("%s/data/os.img" %(self.build_dir,),
                                          "%s/install_root" %(self.build_dir,))
        else:
            self.instloop = SparseExt3LoopbackMount("%s/data/os.img"
                                                    %(self.build_dir,),
                                                    "%s/install_root"
                                                    %(self.build_dir,),
                                                    image_size)
            

        if not self.instloop.setup():
            self.teardown()
            return False

        if base_on == "":
            # create a few directories needed if it's a new image
            try:
                os.mkdir(self.build_dir + "/install_root/etc")
                os.mkdir(self.build_dir + "/install_root/boot")
                os.mkdir(self.build_dir + "/install_root/var")
                os.mkdir(self.build_dir + "/install_root/var/log")
                os.mkdir(self.build_dir + "/install_root/var/cache")
                os.mkdir(self.build_dir + "/install_root/var/cache/yum")
            except OSError:
                print "Cannot create directory"
                self.teardown()
                return False

        # bind mount system directories into install_root/
        for f in ["/sys", "/proc", "/dev", "/dev/pts", "/selinux"]:
            b = BindChrootMount(f, "%s/install_root" %(self.build_dir,))
            if b.mount():
                self.bindmounts.append(b)
            else:
                print "Cannot mount special file system %s"%f
                self.teardown()
                return False

        # make sure /etc/mtab is current inside install_root
        try:
            os.symlink("../proc/mounts", self.build_dir + "/install_root/etc/mtab")
        except OSError:
            print "Cannot create symlink %s/etc/mtab -> ../proc/mounts"%(self.build_dir)
            self.teardown()
            return False

        # write an /etc/fstab file
        fstab = open(self.build_dir + "/install_root/etc/fstab", "w")
        fstab.write("/dev/mapper/livecd-rw   /                       ext3    defaults,noatime 0 0\n")
        fstab.write("devpts                  /dev/pts                devpts  gid=5,mode=620  0 0\n")
        fstab.write("tmpfs                   /dev/shm                tmpfs   defaults        0 0\n")
        fstab.write("proc                    /proc                   proc    defaults        0 0\n")
        fstab.write("sysfs                   /sys                    sysfs   defaults        0 0\n")
        fstab.close()

        b = BindChrootMount("%s/yum-cache" %(self.build_dir,),
                            "%s/install_root" %(self.build_dir,),
                            "/var/cache/yum")
        if b.mount():
            self.bindmounts.append(b)
        else:
            print "Cannot bind mount /var/cache/yum"
            self.teardown()
            return False

        # setup yum.conf (this file live _outside_ the intall root)
        yumconf = open(self.build_dir + "/yum.conf", "w")
        yumconf.write("[main]\n")
        yumconf.write("cachedir=/var/cache/yum\n")
        yumconf.write("debuglevel=1\n")
        yumconf.write("logfile=/var/log/yum.log\n")
        yumconf.write("pkgpolicy=newest\n")
        yumconf.write("distroverpkg=redhat-release\n")
        yumconf.write("tolerant=1\n")
        yumconf.write("exactarch=1\n")
        yumconf.write("retries=20\n")
        yumconf.write("obsoletes=1\n")
        yumconf.write("gpgcheck=0\n")
        yumconf.write("\n")
        yumconf.close()

        self.repo_num = 0
        return True


    def unmount(self):
        """detaches system bind mounts and install_root for the file system and tears down loop devices used"""
        
        try:
            os.unlink(self.build_dir + "/install_root/etc/mtab")
        except OSError:
            pass

        # TODO: need to handle when unmount fails because of lingering
        # processes that has open files
        if self.instloop:
            self.bindmounts.reverse()
            for b in self.bindmounts:
                b.umount()
            self.instloop.cleanup()
            try:
                os.unlink(self.build_dir + "/yum.conf")
            except OSError:
                pass
            shutil.rmtree("%s/yum-cache" %(self.build_dir,), ignore_errors=True)

            self.instloop = None

    def teardown(self):
        """releases all resources and removes all temporary files"""

        # ensure we've detached the install_root
        self.unmount()

        # this removes all data used in the temporary build directory
        try:
            os.unlink(self.build_dir + "/data/os.img")
            os.rmdir(self.build_dir + "/data")
        except OSError:
            pass
        shutil.rmtree("%s/out" %(self.build_dir,), ignore_errors=True)
        if "/var/tmp/livecd-creator/build-" in self.build_dir:
            shutil.rmtree(self.build_dir, ignore_errors=True)

    def addRepository(self, name, url):
        """adds a yum repository to temporary yum.conf file used"""

        yumconf = open(self.build_dir + "/yum.conf", "a")
        yumconf.write("[lcdr_%s]\n"%name)
        yumconf.write("name=Live CD creator repo for '%s'\n"%name)
        yumconf.write("baseurl=%s\n"%url)
        yumconf.write("enabled=1\n")
        yumconf.write("gpgcheck=0\n")
        yumconf.write("\n")
        yumconf.close()

    def installPackages(self, packageList, excludePackageList):
        """install packages into target file system"""
        def run_in_root():
            os.chroot("%s/install_root" %(self.build_dir,))

        packages = ""
        for p in packageList:
            packages += " %s"%p

        touch("%s/install_root/var/log/yum.log" %(self.build_dir,))
        if os.system("/usr/bin/yum -y -c %s/yum.conf --disablerepo=* --enablerepo=lcdr_* --installroot=%s/install_root install %s"%(self.build_dir, self.build_dir, packages)) != 0:
            print "Error installing packages"
            return False

        additional_packages = []

        # now run through all .conf files and collect packages to install
        for root, dirs, files in os.walk("%s/install_root/etc/livecd"%(self.build_dir)):
            files.sort()
            for file in files:
                f = os.popen("%s/%s pkgadd"%(root, file))
                pkg_from_f = (f.read().strip()).splitlines()
                f.close()
                additional_packages += pkg_from_f

        # exclude the packages given on the command line with --exclude-package
        for e in excludePackageList:
            keep_removing = True
            while keep_removing:
                try:
                    additional_packages.remove(e)
                except ValueError:
                    keep_removing = False

        # now install the additional packages...
        packages = ""
        if len(additional_packages) > 0:
            for p in additional_packages:
                packages += " %s"%p
            if os.system("/usr/bin/yum -y -c %s/yum.conf --disablerepo=* --enablerepo=lcdr_* --installroot=%s/install_root install %s"%(self.build_dir, self.build_dir, packages)) != 0:
                print "Error installing packages"
                return False

        touch("%s/install_root/etc/shadow" %(self.build_dir,))
        touch("%s/install_root/etc/gshadow" %(self.build_dir,))        

        # now run through all the post scripts from livecd scripts
        for root, dirs, files in os.walk("%s/install_root/etc/livecd"%(self.build_dir)):
            files.sort()
            for file in files:
                subprocess.call(["/etc/livecd/%s" %(file,), "post"],
                                preexec_fn = run_in_root)

        # Create initramfs
        #
        shutil.copy("/usr/lib/livecd-creator/mayflower",
                        "%s/install_root/sbin/mayflower" %(self.build_dir,))
        shutil.copy("/usr/lib/livecd-creator/run-init",
                        "%s/install_root/sbin/run-init" %(self.build_dir,))
        # modules needed for booting (this is butt ugly and we need to retrieve this from elsewhere, e.g. the kernel)
        mayflowerconf = open(self.build_dir + "/install_root/etc/mayflower.conf", "w")
        mayflowerconf.write('MODULES+="cdrom ide-cd ahci loop dm_snapshot squashfs ext3 ehci_hcd uhci_hcd ohci_hcd usb_storage sd_mod sr_mod usbhid ata_piix "\n')
        mayflowerconf.write('MODULES+="sata_mv sata_qstor sata_sis sata_uli "\n')
        mayflowerconf.write('MODULES+="sata_nv sata_sil24 sata_svw sata_via "\n')
        mayflowerconf.write('MODULES+="sata_promise sata_sil sata_sx4 sata_vsc "\n')
        mayflowerconf.write('MODULES+="ata_generic pata_ali pata_amd pata_artop pata_atiixp pata_cmd64x pata_cs5520 pata_cs5530 pata_cs5535 pata_cypress pata_efar pata_hpt366 pata_hpt37x pata_hpt3x2n pata_hpt3x3 pata_isapnp pata_it821x pata_jmicron pata_marvell pata_mpiix pata_netcell pata_ns87410 pata_oldpiix pata_optidma pata_opti pata_pcmcia pata_pdc2027x pata_pdc202xx_old pata_qdi pata_serverworks pata_sil680 pata_sis pata_sl82c105 pata_triflex pata_via pdc_adma "\n')        
        mayflowerconf.close()

        subprocess.call(["/sbin/mayflower", "-f", "/boot/livecd-initramfs.img",
                         get_kernel_version(self.build_dir)],
                        preexec_fn=run_in_root)
        for f in ("/sbin/mayflower", "/sbin/run-init", "/etc/mayflower.conf"):
            os.unlink("%s/install_root/%s" %(self.build_dir, f))

        # finally relabel all files
        subprocess.call(["/sbin/fixfiles", "restore"], preexec_fn=run_in_root)
        return True

    def configureBootloader(self):
        """configure the boot loader"""
        
        # set up boot loader
        #
        # TODO:
        #  - fix for archs not using grub
        #  - fix for non-i386
        #  - error handling
        #
        shutil.copyfile("%s/install_root/boot/vmlinuz-%s"
                        %(self.build_dir, get_kernel_version(self.build_dir,)),
                        "%s/out/isolinux/vmlinuz" %(self.build_dir,))

        shutil.copyfile("%s/install_root/boot/livecd-initramfs.img"
                        %(self.build_dir,),
                        "%s/out/isolinux/initrd.img" %(self.build_dir,))
        os.unlink("%s/install_root/boot/livecd-initramfs.img"
                  %(self.build_dir,))

        shutil.copy("%s/install_root/usr/lib/syslinux/isolinux.bin" %(self.build_dir,),
                    "%s/out/isolinux/isolinux.bin" %(self.build_dir,))
        shutil.copy("%s/install_root/usr/lib/syslinux/vesamenu.c32" %(self.build_dir,),
                    "%s/out/isolinux/vesamenu.c32" %(self.build_dir,))
        shutil.copy("%s/install_root/usr/lib/anaconda-runtime/syslinux-vesa-splash.jpg" %(self.build_dir,),
                    "%s/out/isolinux/splash.jpg" %(self.build_dir,))

        cfg = """
default vesamenu.c32
timeout 600

menu background splash.jpg
menu title Welcome to Fedora!
menu color border 0 #ffffffff #00000000
menu color sel 0 #ffffffff #ff000000
menu color title 0 #ffffffff #00000000
menu color tabmsg 0 #ffffffff #00000000
menu color unsel 0 #ffffffff #00000000
menu color hotsel 0 #ff000000 #ffffffff
menu color hotkey 0 #ffffffff #ff000000

label linux
  menu label %(label)s
  kernel vmlinuz
  append initrd=initrd.img  ro quiet root=CDLABEL=%(label)s rootfstype=iso9660 livecd

label runfromram
  menu label %(label)s from RAM
  kernel vmlinuz
  append initrd=initrd.img ro quiet root=CDLABEL=%(label)s rootfstype=iso9660 livecd livecd_ram
""" %{"label": self.fs_label}

        cfgf = open("%s/out/isolinux/isolinux.cfg" %(self.build_dir,), "w")
        cfgf.write(cfg)
        cfgf.close()
        
        # TODO: enable external entitity to partipate in adding boot entries

    def createIso(self, filename):
        """write out the live CD ISO"""
        subprocess.call(["/usr/bin/mkisofs", "-o", "%s.iso" %(filename,),
                         "-b", "isolinux/isolinux.bin",
                         "-c", "isolinux/boot.cat",
                         "-no-emul-boot", "-boot-load-size", "4",
                         "-boot-info-table", "-J", "-r", "-hide-rr-moved",
                         "-V", "%s" %(filename,), "%s/out" %(self.build_dir)])

    def createSquashFS(self):
        """create compressed squashfs file system"""
        # FIXME: mksquashfs segfaults if PWD isn't set in the environment
        subprocess.call(["/sbin/mksquashfs", "os.img", "sysroot",
                         "../out/squashfs.img"],
                        cwd="%s/data" %(self.build_dir,),
                        env={"PWD": "%s/data" %(self.build_dir,)})

def usage():
    print "usage: livecd-creator [--help] "
    print "                      [--repo=<name1>,<url1> ...] [--repo=<name2>,<url2>]"
    print "                      --package=<p1> [--package=<p2> ...]"
    print "                      [--exclude-package=<e1>] --exclude-package=<e2> ...]"
    print "                      [--base-on=<path-to-iso-file>]"
    print "                      [--fslabel=<label>]"
    print ""
    print " --help             : Print usage and exit"
    print " --repo             : Path to yum repository"
    print " --package          : Include this package"
    print " --exclude-package  : Exclude this package"
    print " --base-on          : Add packages to an existing live CD iso9660 image"
    print " --fslabel          : File system label (default: livecd-YYYYMMDD-HHMI)"
    print ""

def main():

    repos = []
    packages = []
    epackages = []
    fs_label = "livecd-" + time.strftime("%Y%m%d-%H%M")
    base_on = ""

    try:
        opts, args = getopt.getopt(sys.argv[1:], "hr:b:p:e:f:",
                                   ["help", "repo=", "base-on=", "package=", "exclude-package=", "fslabel="])
    except getopt.GetoptError:
        usage()
        sys.exit(2)
    output = None
    verbose = False
    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
            sys.exit(0)
        if o in ("-r", "--repo"):
            (name, url) = a.split(",")
            for (n, u) in repos:
                if n == name:
                    print "Repo name '%s' is already in use"%n
                    sys.exit(2)
            repos.append((name, url))
            continue
        if o in ("-p", "--package"):
            packages.append(a)
            continue
        if o in ("-e", "--exclude-package"):
            epackages.append(a)
            continue
        if o in ("-f", "--fslabel"):
            fs_label = a
            continue
        if o in ("-b", "--base-on"):
            base_on = a
            continue
        print "Unknown option %s"%o
        sys.exit(2)

    if len(packages) == 0:
        print "No packages specified."
        print ""
        usage()
        sys.exit(1)

    if len(repos) == 0:
        print "No repositories specified."
        print ""
        usage()
        sys.exit(1)

    target = InstallationTarget()

    if not target.setup(3*1024, fs_label, base_on):
        print "Cannot setup installation target. Aborting."
        sys.exit(1)

    try:
        for (n, u) in repos:
            target.addRepository(n, u)

        if not target.installPackages(packages, epackages):
            target.teardown()
            sys.exit(1)
            
        target.configureBootloader()
    except:
        target.teardown()
        print "Error during installation..."
        sys.exit(1)

    #os.system("/bin/bash")

    target.unmount()
    target.createSquashFS()
    target.createIso(fs_label)
    target.teardown()

if __name__ == "__main__":
    main()
